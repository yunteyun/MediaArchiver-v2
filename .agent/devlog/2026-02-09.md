# 2026-02-09 開発日誌

## 本日の目標
- Phase 12-6: ストレージクリーンアップ機能の再実装と完了
- 設定画面のUI改善（サムネイル設定の独立タブ化）

## 実装・作業内容
1. **ストレージクリーンアップ機能の実装 (Phase 12-6)**
   - Backend: `thumbnailCleanupService.ts` に診断・削除ロジックを実装
   - IPC: `thumbnail:cleanup` ハンドラと Preload API を追加
   - Frontend: `StorageCleanupSection` コンポーネントを作成し、設定画面に統合
   - **バグ修正**: `getThumbnailDir` がプロファイルIDサブディレクトリを含むパスを返していた問題を修正（`thumbnails/` 直下を参照するように変更）

2. **設定画面のUI改善 (Phase 12-16)**
   - `SettingsModal` に独立した「サムネイル」タブを追加
   - 一般タブから「サムネイルサイズ」「ホバー動作」「プレビューフレーム数」を移動
   - バックアップタブから「サムネイル診断」を移動
   - 用語を「ストレージ管理」から「サムネイル管理」に統一

3. **ファイル削除の安全性向上 (ゴミ箱機能)**
   - `fs.unlink` による直接削除を廃止し、`shell.trashItem` を使用するように変更
   - 削除確認ダイアログに「ゴミ箱に移動」「完全に削除」の選択肢を追加
   - 重複ファイル削除時もゴミ箱を経由するように変更（誤削除防止）
   - **バグ修正**: `preview_frames` がカンマ区切り文字列として保存されているのにJSONパースしようとしていた問題を修正 (`split(',')` に変更)

## 成果
- 孤立サムネイルの検出と削除が可能になり、ストレージ容量を節約できるようになった
- 設定画面が整理され、サムネイル関連の設定へのアクセス性が向上した
- ファイル削除が「ゴミ箱経由」になり、誤操作によるデータ消失リスクが大幅に低減した
- ディレクトリパスのバグを特定・修正し、機能が正しく動作することを確認した

## 課題と解決
- **課題**: 型定義の共有（`DiagnosticResult`）が Frontend/Backend 間でうまくいかなかった
- **解決**: Frontend 側でローカルに型定義を再宣言することで、ビルドエラーを回避しつつ型安全性を確保した

## 次回の予定
- Phase 12-B の残りのタスク（もしあれば）
- Phase 13 に向けた準備

## 追記 (15:20) - Phase 12-17B & 12-18 完了

### 実装内容

#### 4. Phase 12-17B: カスタム削除ダイアログ実装
Electronの標準ダイアログ(`dialog.showMessageBox`)ではチェックボックス付きのUIを実現できないため、Reactコンポーネントによるカスタムダイアログを実装しました。

- **`DeleteConfirmDialog.tsx`**:
    - モーダルコンポーネントとして実装
    - 「完全に削除する」チェックボックスを提供
    - デフォルトはOFF（ゴミ箱へ移動）
    - キーボードショートカット対応（Enterで実行、Escでキャンセル）
- **IPC通信**:
    - `file:showDeleteDialog`: MainプロセスからRendererへダイアログ表示を要求
    - `file:confirmDelete`: Rendererから削除実行を要求（完全削除時はMain側で二重確認）

#### 5. Phase 12-18: サムネイル再作成最適化
既存の「サムネイル再作成」機能が、プレビューフレーム（スクラブサムネイル）が既に存在していても無条件で再生成していた問題を修正しました。

- **`file.ts` (IPC)**:
    - `getPreviewFrameCount()` 設定値を取得
    - `existingFrames.length === frameCount` の場合、生成プロセスをスキップ
    - 設定値が0の場合もスキップ
    - 挙動が分かるようにコンソールログ出力を追加

### 成果（追記）
- **User Experience**: 削除時の「ゴミ箱」か「完全削除」かの選択が明確になり、キーボード操作でスムーズに実行できるようになった。
- **Performance**: 無駄なFFmpeg処理が削除され、サムネイル再作成のレスポンスが向上した。
- **Documentation**: 全Phase完了に伴い、ROADMAPを更新。次はPhase 13へ。

## 追記 (15:45) - Phase 12-18 バグ修正

### 問題
ユーザーから「サムネイル再作成を実行してもスクラブサムネイルが生成されない」との報告を受けました。

### 原因
`file.ts` の 87-88行目に、既存フレーム数が設定値と一致する場合に再生成をスキップするロジックがありました。
これは、ユーザーが明示的に「サムネイル再作成」を選択した場合でも適用されてしまい、期待通りに動作しませんでした。

### 修正内容
- 既存フレーム数チェックを削除
- ユーザーが「サムネイル再作成」を選択した場合は、常にプレビューフレームを再生成するように変更
- ログ出力を改善（再生成開始・成功・失敗を明確に表示）

### 成果
- **UX改善**: 「サムネイル再作成」が期待通りに動作するようになった
- **デバッグ性向上**: コンソールログで何が起こっているかが明確になった

## 追記 (15:52) - スキャナー最適化

### 問題
プレビューフレーム設定が 0 の場合、動画ファイルが毎回再スキャンされる可能性がありました。

### 原因
`scanner.ts` の `isComplete` チェックが、プレビューフレームの存在のみを確認していました。
設定値が 0 の場合、プレビューフレームは生成されないため、常に「未完了」とみなされていました。

### 修正内容
```typescript
// Videos require both thumbnail and preview frames (only if setting > 0)
const isComplete = type === 'video'
    ? (hasThumbnail && (hasPreviewFrames || previewFrameCountSetting === 0))
    : (!isMedia || hasThumbnail);
```

設定値が 0 の場合は、プレビューフレームがなくても「完了」とみなすように変更しました。

### 成果
- **パフォーマンス改善**: 不要な再スキャンを防止
- **設定の尊重**: ユーザーがプレビューフレームを無効にした場合、その設定が正しく反映される

## 追記 (16:15) - スキャナー改善: プレビューフレームファイルの存在確認

### 問題
ユーザーから「プレビューフレームがない動画をスクラブするとエラーが出る」との報告を受けました。
調査の結果、DBには `preview_frames` データが存在するが、実際のファイルが削除されていることが判明しました。

### 原因
スキャナーの `hasPreviewFrames` チェックが、DBレコードの存在のみを確認していました:
```typescript
const hasPreviewFrames = !!existing?.preview_frames;
```

これでは、ファイルが削除されていても「存在する」と判断されてしまいます。

### 修正内容
実際のファイルが存在するかを確認するように変更:
```typescript
// Check if preview frames actually exist on disk (not just in DB)
let hasPreviewFrames = false;
if (existing?.preview_frames) {
    const framePaths = existing.preview_frames.split(',').filter(Boolean);
    // Check if at least one frame file exists
    hasPreviewFrames = framePaths.length > 0 && framePaths.some(framePath => {
        try {
            return fs.existsSync(framePath);
        } catch {
            return false;
        }
    });
}
```

### 成果
- **エラー防止**: スクラブ時のファイル読み込みエラーを防止
- **自動修復**: 孤立したDBレコードを検出し、再スキャン時に自動的にプレビューフレームを再生成
- **データ整合性**: DBとファイルシステムの整合性を保つ

## 追記 (19:40) - Phase 13-1 & 13-2 (途中)

### 実装内容

#### 1. Phase 13-1: 画像ファイルの扱い改善
`mediaType` だけでは区別できなかった「アニメーションする画像」（GIF/WebP）を識別できるようにしました。

- **マイグレーション**: `005_add_is_animated.ts` を作成し、`files` テーブルに `is_animated` カラムを追加。
- **スキャナー**: `checkIsAnimated` ロジックを実装し、バイナリヘッダチェックでアニメーションGIF/WebPを判定。
- **目的**: 将来的にAPNGやAVIFに対応する際も、このフラグだけで「動く画像」として扱えるようにする抽象化。

#### 2. Phase 13-2: UIユーティリティ基盤 (進行中)
UIロジックをコンポーネントから分離・共通化するリファクタリングを開始しました。

- **`src/utils/path.ts`**:
    - フォルダ名表示ロジック（`getDisplayFolderName`）を分離。
    - UI表示専用であることを明記し、DB層での誤用を防止。
- **`src/utils/tag.ts`**:
    - タグの整形・省略表示ロジック（`getVisibleTags`）を分離。
    - `FileCard`, `LightBox`, 将来の別Viewでロジックを統一可能に。
- **`src/index.css`**:
    - ファイル種別バッジの色をCSS変数（デザイントークン）として定義。
    - テーマ切り替え（Dark/Light/Custom）への布石。

### 次の予定
- `FileCard` コンポーネントの大幅更新（完了）
- 新しいUtilsとデザイントークンの適用（完了）

## 追記 (21:55) - Phase 13 & 13.5 完了、Phase 14 計画策定

### 実装内容

#### 3. Phase 13 完了: FileCard 基礎設計
前回の日誌以降、以下の実装を完了しました。

- **情報レイアウト刷新 (Phase 13-3)**:
    - 情報エリアを下寄せ配置に変更し、視線の流れを自然に。
    - 縦積み構造（flex-col）を採用し、将来の項目追加に柔軟に対応。
    - `min-height` + `max-height` + `overflow-hidden` を設定し、Virtual Scrollでの暴走を防止。

- **タグ表示ルール (Phase 13-4)**:
    - `utils/tag.ts` を実装し、タグ整形ロジックを分離。
    - `FILE_CARD_MAX_VISIBLE_TAGS` (5個) を定義し、それ以上は `+N` で省略表示。

- **配色ルール (Phase 13-5)**:
    - デザイントークンとしてのCSS変数を適用。

#### 4. Phase 13.5: タグ表示の視認性改善
Phase 13完了直後、ユーザーフィードバックに基づき「タグの視認性」を改善する追加対応を行いました。

- **配置変更**: サムネイル上のオーバーレイ（hover時のみ）から、下段情報エリア（常時表示）へ移動。
- **スタイル変更**: 半透明バッジをやめ、完全不透明に変更（背景色負けを解消）。
- **調整**: ファイル名とタグの間隔を詰め (`gap-0`)、情報の流れをスムーズに。

**成果**: 一覧を見た瞬間に「整理済みかどうか」が直感的に分かるようになりました。

#### 5. Phase 14 計画策定: 表示モードシステム
次のフェーズ「表示モードシステム」の計画を策定しました。
リスクを最小化するため、**MVP（Minimum Viable Product）アプローチ**を採用します。

- **MVP範囲 (Phase 14-1, 14-2, 14-6)**:
    - 基盤整備、標準モード確立、UI切り替えボタン実装。
    - まずは「切り替えられること」をゴールにする。
- **拡張版 (Phase 14-3, 14-4, 14-5)**:
    - 漫画モード、動画モード、WhiteBrowser風モードは、MVP安定後に順次実装。

### 明日の予定
- Phase 14-1: 基盤整備（設定ストア、定数定義）の実装開始

